Insurance Cost Estimator
========================================================

```{r setup}
require(knitr)
require(XML)
require(plyr)
require(ggplot2)
require(RCurl)
require(stringr)
require(reshape)
require(scales)
# require(RSocrata)

source('func.r')
opts_chunk$set(warning = FALSE)

```


## Declare available policies

Policy attributes include a name, the individual deductible, the family deductible, the copay percentage (as the share paid by the insurer), the individual out-of-pocket maximum, the family out-of-pocket maximum, and the monthly premium.

Update, Dec 13, 2013: the available policies can be fetched from http://data.healthcare.gov instead of being fabricated.

Update: Jan 3, the healthcare.gov policy descriptions have age-based premium levels 
```{r import.config}


state <- 'VA'
county <- 'ALBEMARLE'



policies <- fetch.policies('VA', 'ALBEMARLE')

# Example policy:
t(policies[policies$Plan.Marketing.Name == 'Bronze Deductible Only POS Plan',])

# Rename the fields
rename.list  <- data.frame( source.name = names(policies), new.name='', keep=TRUE)
rownames(rename.list) <- rename.list$source.name
# convert everything to lower case and remove multiple periods
rename.list$new.name <- tolower(gsub('\\.+','.',rename.list$source.name))

# Compress the premium column names
rename.list$new.name <- gsub('premium.adult.individual.age.','prem.ind.',rename.list$new.name)
rename.list$new.name <- gsub('premium.couple.','prem.cpl.',rename.list$new.name)

# Field-by-field renaming. Verbose for clarity
rename.list['Plan.ID...Standard.Component',                'new.name'] <- 'plan.id'
rename.list['Plan.Marketing.Name',                         'new.name'] <- 'plan.name'
rename.list['Medical.Deductible...individual...standard',  'new.name'] <- 'med.ded.indv' 
rename.list['Medical.Deductible..family...standard',       'new.name'] <- 'med.ded.fam' 
rename.list['Primary.Care.Physician....standard',          'new.name'] <- 'pcp.share'
rename.list['Specialist....standard',                      'new.name'] <- 'spec.share'
rename.list['Emergency.Room....standard',                  'new.name'] <- 'er.share'
rename.list['Inpatient.Facility....standard',              'new.name'] <- 'hosp.fac.share'
rename.list['Inpatient.Physician...standard',             'new.name'] <- 'hosp.doc.share'
rename.list['Generic.Drugs...standard',                    'new.name'] <- 'gen.rx.share'
rename.list['Non.preferred.Brand.Drugs...standard',        'new.name'] <- 'non.pref.rx.share'
rename.list['Specialty.Drugs...standard',                  'new.name'] <- 'spec.rx.share'
rename.list['Medical.Maximum.Out.Of.Pocket...individual...standard', 'new.name'] <- 'ind.oop.max'
rename.list['Medical.Maximum.Out.of.Pocket...family...standard',     'new.name'] <- 'fam.oop.max'

# Apply the new names
names(policies) <- rename.list$new.name

# The "MOC" and "MO" plans seem to have unusually high premiums
# Compare:
policies[grep('3750',policies$plan.name),]

# Exclude them for now
policies <- policies[grep('MO$|MOC$',policies$plan.name, invert=TRUE),]


# Some of the columns containing dollar signs need to become numeric
# There are tons of columns that won't convert directly
# names(policies)[which(apply(policies, 2, function(x) any(grepl("\\$", x))))]

# The dollar-only columns have to be individually selected
dollar.cols <- names(policies)[grep('\\.ded\\.|\\.oop\\.|premium\\.child|prem\\.ind|prem\\.cpl', names(policies) )]

dollar.to.number <- function(dollars){
  as.numeric(gsub('\\$','',dollars))
}

policies[,dollar.cols] <- sapply(policies[,dollar.cols], dollar.to.number)

# grep the copay and coinsurance values out of the various fields
percent.pattern <- '([0-9]{1,})%'
price.pattern <- '\\$([0-9]{1,})'

parse.percents <- function(target.text){
  as.numeric(gsub('\\%','' , regmatches(target.text, gregexpr(percent.pattern, target.text)) )) * 0.01
  }

parse.prices <- function(target.text){ 
as.numeric(gsub('\\$','' , regmatches(target.text, gregexpr(price.pattern, target.text)) ))
  }

parse.prices(policies$pcp.share)
parse.percents(policies$spec.share)

copays <- sapply(policies[,grep('share',names(policies))], parse.prices)
coinsurance <- sapply(policies[,grep('share',names(policies))], parse.percents)

copays <- data.frame(copays)
copays[is.na(copays)] <- 0
coinsurance <- data.frame(coinsurance)
coinsurance[is.na(coinsurance)] <- 0
names(copays) <- gsub('share','copay',names(copays))
names(coinsurance) <- gsub('share','coinsurance',names(coinsurance))

policies <- cbind(
            policies,
            copays, 
            coinsurance)

```

The following dummy policies were created for a previous version
```{r policies}

old.policies <- rbind(
    data.frame(plan.name='2014 CIGNA Choice Fund with HSA' , med.ded.indv=1500, med.ded.fam=3000, copay.pct=.80, ind.oop.max=3000, fam.oop.max=6000, premium=(186.75*2))
,
    data.frame(plan.name='2014 CIGNA OAP (PPO) Standard Plan' , med.ded.indv=600, med.ded.fam=1200, copay.pct=.80, ind.oop.max=3000, fam.oop.max=6000, premium=(236.67*2))
,
    data.frame(plan.name='2013 CIGNA OAP (PPO) Gold Plan' , med.ded.indv=600, med.ded.fam=1200, copay.pct=.80, ind.oop.max=2400, fam.oop.max=4800, premium=(166.67*2))
)
old.policies$plan.id <- row.names(old.policies)

old.policies

```

## Declare family members

Each family member has a name, an age, a baseline cost for doctor's visits, a risk of incurring sickness-related expenses, and a risk of catastrophic injury or illness. 

The risk factors are probabilities passed to a binomial distribution. If the result is 1, a Poisson distribution is used to estimate costs. 

In the following sample family, Parent A visits the doctor less than Parent A, and the children are more likely to get sick. Everyone has a 1% chance of catastrophic sickness or injury.

TODO: all the risk factors should correspond to the plans' different deductible, copay, and coinsurance attributes.

```{r insured}
insured <- rbind(
    data.frame(Name='Parent A' , Age=40, VisitBase=150,  SickRisk=0.1, CatRisk=0.01)
    ,
    data.frame(Name='Parent B' , Age=40,  VisitBase=500,  SickRisk=0.2, CatRisk=0.01)
    ,
    data.frame(Name='Child C'  , Age=5, VisitBase=250,  SickRisk=0.4, CatRisk=0.01)
    ,
    data.frame(Name='Child D' ,  Age=7, VisitBase=250,  SickRisk=0.4, CatRisk=0.01)
    ,
    data.frame(Name='Child E' ,  Age = 9, VisitBase=250,  SickRisk=0.4, CatRisk=0.01)
      ,
    data.frame(Name='Child F' ,  Age = 13, VisitBase=250,  SickRisk=0.4, CatRisk=0.01)
        ,
    data.frame(Name='Child G' ,  Age = 15, VisitBase=250,  SickRisk=0.4, CatRisk=0.01)
)
```

## Based on the family attributes, calculate a total family premium for each policy

```{r premiums}
prem.cols <- names(policies)[grep('prem\\.|premium\\.child',names(policies))]

prems <- melt(policies[c('plan.id', prem.cols)], id='plan.id')
prems$age <-  gsub('prem\\.ind\\.|prem\\.cpl\\.','', prems$variable)
prems$age <- as.numeric(prems$age)
prems[prems$variable=='premium.child','age'] <- 20
prems$customer <- ifelse(grepl('cpl', prems$variable), 'Couple', 
                         ifelse(grepl('ind', prems$variable), 'Individual',
                         'Child')
                         )

# A test case
ages <- subset(prems, plan.id=='20507VA1170001' & customer == 'Individual')$age
premiums <- subset(prems, plan.id=='20507VA1170001' & customer == 'Individual')$value
all.ages <- seq(1,100)
test.approx <- approx(ages, premiums, xout=all.ages, rule=2)
test.prems <- data.frame(ages=test.approx$x, prems=test.approx$y)

# This can't be extended to all the categories, since children only have one record.
# Convert each "Child" record to an "Individual" record."
prems$customer <- ifelse(prems$customer=='Child', 'Individual',prems$customer)
prems <- arrange(prems, plan.id, customer, age)

prems <- ddply(prems, .(plan.id,customer), function(x) {data.frame(
                               age=approx(x$age, x$value, xout=seq(1,100), rule=2)$x,
                               prem=approx(x$age, x$value, xout=seq(1,100), rule=2)$y
                              )
                            })
# subset(prems, plan.id=='20507VA1170001')
# subset(policies, plan.id=='20507VA1170001')

# TODO: fix this to use couples' rates where applicable, and to cap premium after the third child.
# as of Jan 3, it's just calling everyone an individual

# Join the insured data frame to the premium costs
ind.prems <- merge(insured[,c('Age','Name')], subset(prems, customer=='Individual'), by.x='Age', by.y='age')
# cap the premium after the third child by zeroing out the premium for every individual not in the first five family members
ind.prems[!ind.prems$Name %in% insured$Name[1:5],'prem'] <- 0
fam.prems <- ddply(ind.prems, .(plan.id), summarize, premium=sum(prem))
```

Reduce the `policies` data frame to only include relevant columns, call the result `plans`

```{r reduce.policies}
plans <- policies[,c('plan.id','plan.name',
                     'med.ded.indv','med.ded.fam',
                     'ind.oop.max','fam.oop.max',
                     names(policies)[grep('copay', names(policies))],
                     names(policies)[grep('coinsurance', names(policies))]
                     )]
plans <- merge(plans,fam.prems)

```


## Run _n_ iterations of the family's possible years with each plan

```{r func.yr}
n <- 500
costs <- yearcosts(insured, n)
subset(costs, cost.iteration == 1)
# The `scenarios` are unique combinations of each policy, family member, and iteration year
scenarios <- explode.scenarios(costs, plans)
head(scenarios)
str(scenarios)
# subset(scenarios, cost.iteration == 1)

# the calculate_family() function aggregates the scenarios to the family level
results <- calculate.family(scenarios, plans)
head(results)
```


Measure the probability densities of the results, by policy. Assign some tail boundaries of interest for later graphing.


```{r densities}
tail.limit.left <- 0.333
tail.limit.right <- 0.666
dxy <- ddply(results, .(plan.name), summarize, dx=density(fam.net.capped)$x, dy=density(fam.net.capped)$y )
dxy <- ddply(dxy, .(plan.name), transform, qleft=quantile(dx, tail.limit.left), qright=quantile(dx, tail.limit.right))
dxy$ytail <- ifelse(dxy$dx <= dxy$qleft | dxy$dx >= dxy$qright , dxy$dy, 0)

```

## Plot the outcomes as kernel densities

Create some range spans so the x axis on each graph can show how much of the net costs are composed of premiums (orange box), deductible costs paid at 100% (yellow box), and post-deductible copays (the amount between the yellow box and the total cost).

```{r ranges}
ranges <- merge(plans, fam.prems)
# annualize the monthly premium
ranges$premium <- ranges$premium * 12
# Calculate the premium + deductible out-of-pocket baseline
ranges$dedplusprem <- ranges$med.ded.fam + ranges$premium 
dummyranges <- ranges
dummyranges$dedplusprem <- dummyranges$premium 
dummyranges$premium <- 0
ranges <- rbind(dummyranges, ranges)
```

Plot the ranges behind the kernel density graphs.

```{r combined plot}
p.dist <- ggplot(results, aes(x=fam.net.capped)) +
          geom_histogram(aes(y = ..density..), binwidth=density(results$fam.net.capped)$bw) +
          geom_area(data=ranges, aes(x=premium , y=0.0015) , fill="orange", alpha=0.5) + 
          geom_area(data=ranges, aes(x=dedplusprem, y=0.0015) , fill="yellow", alpha=0.5) +
          geom_area(data=dxy,aes(x=dx,y=ytail ), fill="green",colour=NA,alpha=0.5) +
          geom_vline(aes(xintercept=fam.net.max),color='red') +
          geom_density(color="blue") +
          facet_wrap( ~ plan.name, ncol=1) +
          scale_y_continuous(limits=c(0,0.002)) +
          scale_x_continuous("Net family costs", labels = dollar)

ggsave(filename='distribution.png',width=6,height=36)

```

<img src="distribution.png" alt="Distribution curves" style="width: 200px;"/>

### Five-Number Summaries instead of graphs

```{r }

cost.summary <- ddply(results, .(plan.id, plan.name), function(x) summary(x$fam.net.capped))
cost.summary <- arrange(cost.summary, Median)
cost.summary

```

## Probability mass instead of density

```{r probabilty.histograms}
sub.results <- subset(results, plan.id==results$plan.id[1])
sub.ranges <- subset(ranges, plan.id==results$plan.id[1])
sub.dxy <- subset(dxy , plan.name == sub.results$plan.name[1])

# geom_histogram() and facet_grid() do not work together, see
# https://groups.google.com/forum/#!topic/ggplot2/jGVzQi6Kmjk
costbin <- 1000
myhist <- function(df, colname, breaks) {
  h <- hist(df[[colname]], breaks = breaks, plot = F)
  xmin <- h$breaks[-length(h$breaks)]  # Min value for each bin
  xmax <- h$breaks[-1]                 # Max value for each bin
  data.frame(xmin, xmax, count = h$counts, total = sum(h$counts), pct=h$counts/sum(h$counts))
}

freqs <- ddply(results, .(plan.id, plan.name), myhist, "fam.net.capped", breaks = seq(0, max(results$fam.net.capped)+costbin, by=costbin))

p.dist <- ggplot(freqs, aes(x=xmin)) +
          geom_area(data=ranges, aes(x=premium , y=1) , fill="orange", alpha=0.5) + 
          geom_area(data=ranges, aes(x=dedplusprem, y=1) , fill="yellow", alpha=0.5) +
 #         geom_histogram(aes(y=..count../sum(..count..)), binwidth=2000, color="black", fill="gray", alpha=0.5) +
          geom_bar(aes(y=pct),width=costbin, color="black", fill="gray", alpha=0.5,stat="identity") +
          geom_vline(data=results, aes(xintercept=fam.net.max),color='red') +
          facet_wrap( ~ plan.name, ncol=1) +
          scale_y_continuous(labels = percent_format()) +
          scale_x_continuous("Net family costs", labels = dollar)

ggsave(filename='distribution_mass.png',width=6,height=36)

```

<img src="distribution_mass.png" alt="Distribution curves" style="width: 200px;"/>
